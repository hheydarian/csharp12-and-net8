# فصل سوم: کنترل جریان، تبدیل انواع و مدیریت استثناها

این فصل تماماً درباره نوشتن کدی است که عملیات ساده روی متغیرها انجام می‌دهد، تصمیم‌گیری می‌کند، تطبیق الگو (pattern matching) انجام می‌دهد و دستورات یا بلوک‌ها را تکرار می‌کند. همچنین یاد خواهید گرفت که چگونه با آرایه‌ها برای ذخیره چندین مقدار کار کنید، چگونه مقادیر متغیر یا عبارت را از یک نوع به نوع دیگر تبدیل کنید، چگونه استثناها را مدیریت کنید و چگونه سرریز (overflow) را در متغیرهای عددی بررسی کنید.

این فصل موضوعات زیر را پوشش می‌دهد:

* عملیات روی متغیرها
* درک دستورات انتخاب (selection statements)
* درک دستورات تکرار (iteration statements)
* ذخیره چندین مقدار در یک آرایه
* تبدیل (Casting) و تبدیل انواع (Converting)
* مدیریت استثناها
* بررسی سرریز (Checking for overflow)

### عملیات روی متغیرها

عملگرها (Operators) عملیات ساده‌ای مانند جمع و ضرب را روی عملوندها (operands) مانند متغیرها و مقادیر لیترال اعمال می‌کنند. عملگرها مقدار جدیدی را برمی‌گردانند که نتیجه عملیات است و می‌تواند به یک متغیر اختصاص داده شود، و همچنین می‌توانند روی عملوندها تأثیر بگذارند.

#### درک عملگرهای دوتایی (Binary Operators)

بیشتر عملگرها دوتایی هستند، به این معنی که روی دو عملوند کار می‌کنند، همان‌طور که در شبه‌کد زیر نشان داده شده است:

```csharp
var resultOfOperation = firstOperand operator secondOperand;
```

مثال‌هایی از عملگرهای دوتایی شامل جمع و ضرب هستند، همان‌طور که در کد زیر نشان داده شده است:

```csharp
int x = 5;
int y = 3;
int resultOfAdding = x + y;
int resultOfMultiplying = x * y;
```

#### درک عملگرهای یگانه (Unary Operators)

برخی عملگرها یگانه هستند، به این معنی که روی یک عملوند تکی کار می‌کنند و می‌توانند قبل یا بعد از عملوند اعمال شوند، همان‌طور که در شبه‌کد زیر نشان داده شده است:

```csharp
var resultOfOperationAfter = onlyOperand operator;
var resultOfOperationBefore = operator onlyOperand;
```

مثال‌هایی از عملگرهای یگانه شامل افزاینده‌ها (incrementors) و بازیابی یک نوع یا اندازه آن به بایت هستند، همان‌طور که در کد زیر نشان داده شده است:

```csharp
int x = 5;
int postfixIncrement = x++;
int prefixIncrement = ++x;
Type theTypeOfAnInteger = typeof(int);
string nameOfVariable = nameof(x);
int howManyBytesInAnInteger = sizeof(int);
```

#### درک عملگرهای سه‌گانه (Ternary Operators)

یک عملگر سه‌گانه روی سه عملوند کار می‌کند، همان‌طور که در شبه‌کد زیر نشان داده شده است:

```csharp
var resultOfOperation = firstOperand firstOperator
  secondOperand secondOperator thirdOperand;
```

مثالی از یک عملگر سه‌گانه، عملگر شرطی `?:` است که مانند یک دستور `if` ساده شده عمل می‌کند. عملوند اول یک عبارت بولی است، عملوند دوم مقداری است که در صورت درست بودن (true) بازگردانده می‌شود، و عملوند سوم مقداری است که در صورت نادرست بودن (false) بازگردانده می‌شود، همان‌طور که در کد زیر نشان داده شده است:

```csharp
// Syntax of conditional operator.
var result = boolean_expression ? value_if_true : value_if_false;

// Example of conditional operator.
string result = x > 3 ? "Greater than 3" : "Less than or equal to 3";

// Equivalent using an if statement.
string result;
if (x > 3)
{
    result = "Greater than 3";
}
else
{
    result = "Less than or equal to 3";
}
```

توسعه‌دهندگان C# باتجربه‌تر تا حد امکان از عملگرهای سه‌گانه استفاده می‌کنند زیرا مختصر هستند و می‌توانند منجر به کدی تمیزتر شوند، البته وقتی به خواندن آن‌ها عادت کنید.

#### کاوش عملگرهای یگانه

دو عملگر یگانه رایج برای افزایش (`++`) و کاهش (`--`) یک عدد استفاده می‌شوند. بیایید کدی نمونه بنویسیم تا نحوه کار آن‌ها را نشان دهیم:

۱. اگر فصل‌های قبلی را تکمیل کرده باشید، پوشه `cs12dotnet8` را از قبل دارید. اگر نه، باید آن را ایجاد کنید.

۲. از ابزار کدنویسی مورد نظر خود برای ایجاد یک Solution و پروژه جدید استفاده کنید، همان‌طور که در لیست زیر تعریف شده است:

* **قالب پروژه:** Console App / console
* **فایل پروژه و پوشه:** Operators
* **فایل Solution و پوشه:** Chapter03
* **Do not use top-level statements:** تیک نخورده باشد (غیرفعال)
* **Enable native AOT publish:** تیک نخورده باشد (غیرفعال)

۳. در `Operators.csproj`، یک بخش `<ItemGroup>` جدید اضافه کنید تا `System.Console` را برای تمام فایل‌های C# با استفاده از ویژگی implicit usings .NET SDK به‌صورت استاتیک وارد کنید، همان‌طور که در نشانه‌گذاری زیر نشان داده شده است:

```xml
<ItemGroup>
  <Using Include="System.Console" Static="true" />
</ItemGroup>
```

۴. در `Program.cs`، دستورات موجود را حذف کنید و سپس دو متغیر عدد صحیح به نام‌های `a` و `b` تعریف کنید، `a` را برابر ۳ قرار دهید، `a` را افزایش دهید در حالی که نتیجه را به `b` اختصاص می‌دهید، و سپس مقادیر آن‌ها را چاپ کنید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
#region Exploring unary operators
int a = 3;
int b = a++;
WriteLine($"a is {a}, b is {b}");
#endregion
```

> **تمرین خوب:**
> من توصیه می‌کنم دستورات مربوط به هر بخش را در `#region` و `#endregion` قرار دهید همان‌طور که در کد قبل نشان داده شده است تا بتوانید به راحتی بخش‌ها را جمع (collapse) کنید. اما من این کار را در وظایف کدنویسی آینده برای صرفه‌جویی در فضا نشان نخواهم داد.

۵. قبل از اجرای برنامه کنسول، از خود بپرسید: فکر می‌کنید مقدار `b` هنگام چاپ چه خواهد بود؟ وقتی به آن فکر کردید، کد را اجرا کنید و پیش‌بینی خود را با نتیجه واقعی مقایسه کنید، همان‌طور که در خروجی زیر نشان داده شده است:

```text
a is 4, b is 3
```

متغیر `b` مقدار ۳ دارد زیرا عملگر `++` **بعد از** انتساب اجرا می‌شود؛ این به عنوان **عملگر پسوندی (postfix operator)** شناخته می‌شود. اگر نیاز دارید که افزایش **قبل از** انتساب انجام شود، آنگاه از **عملگر پیشوندی (prefix operator)** استفاده کنید.

۶. دستورات را کپی و پیست کنید، و سپس آن‌ها را تغییر دهید تا متغیرها را تغییر نام دهید و از عملگر پیشوندی استفاده کنید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
int c = 3;
int d = ++c; // Prefix means increment c before assigning it.
WriteLine($"c is {c}, d is {d}");
```

۷. کد را دوباره اجرا کنید و به نتیجه توجه کنید، همان‌طور که در خروجی زیر نشان داده شده است:

```text
a is 4, b is 3
c is 4, d is 4
```

> **تمرین خوب:**
> به دلیل سردرگمی بین پیشوند و پسوند برای عملگرهای افزایش و کاهش هنگام ترکیب با یک انتساب، طراحان زبان برنامه‌نویسی Swift تصمیم گرفتند پشتیبانی از این عملگر را در نسخه ۳ حذف کنند. توصیه من برای استفاده در C# این است که هرگز استفاده از عملگرهای `++` و `--` را با یک عملگر انتساب، `=` ترکیب نکنید. عملیات را به عنوان دستورات جداگانه انجام دهید.

#### کاوش عملگرهای حسابی دوتایی

افزایش و کاهش عملگرهای حسابی یگانه هستند. سایر عملگرهای حسابی معمولاً دوتایی هستند و به شما اجازه می‌دهند عملیات حسابی را روی دو عدد انجام دهید، همان‌طور که در زیر نشان داده شده است:

۱. دستوراتی اضافه کنید تا مقادیری را به دو متغیر عدد صحیح به نام‌های `e` و `f` تعریف و اختصاص دهید، و سپس پنج عملگر حسابی دوتایی رایج را روی دو عدد اعمال کنید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
int e = 11;
int f = 3;
WriteLine($"e is {e}, f is {f}");
WriteLine($"e + f = {e + f}");
WriteLine($"e - f = {e - f}");
WriteLine($"e * f = {e * f}");
WriteLine($"e / f = {e / f}");
WriteLine($"e % f = {e % f}");
```

۲. کد را اجرا کنید و به نتیجه توجه کنید، همان‌طور که در خروجی زیر نشان داده شده است:

```text
e is 11, f is 3
e + f = 14
e - f = 8
e * f = 33
e / f = 3
e % f = 2
```

برای درک عملگرهای تقسیم `/` و باقی‌مانده `%` هنگامی که روی اعداد صحیح اعمال می‌شوند، باید به دوران دبستان فکر کنید. تصور کنید یازده آبنبات و سه دوست دارید.
چگونه می‌توانید آبنبات‌ها را بین دوستانتان تقسیم کنید؟ می‌توانید به هر یک از دوستانتان سه آبنبات بدهید، و دو تا باقی می‌ماند. آن دو آبنبات **باقی‌مانده** (modulus) هستند. اگر دوازده آبنبات داشتید، هر دوست چهار تا می‌گرفت و هیچی باقی نمی‌ماند، پس باقی‌مانده ۰ می‌شد.

۳. دستوراتی اضافه کنید تا مقداری را به یک متغیر `double` به نام `g` تعریف و اختصاص دهید تا تفاوت بین تقسیم اعداد حسابی (whole-number) و اعداد حقیقی (real-number) را نشان دهید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
double g = 11.0;
WriteLine($"g is {g:N1}, f is {f}");
WriteLine($"g / f = {g / f}");
```

۴. کد را اجرا کنید و به نتیجه توجه کنید، همان‌طور که در خروجی زیر نشان داده شده است:

```text
g is 11.0, f is 3
g / f = 3.6666666666666665
```

اگر عملوند اول یک عدد ممیز شناور باشد، مانند `g` با مقدار `11.0`، آنگاه عملگر تقسیم یک مقدار ممیز شناور برمی‌گرداند، مانند `3.6666666666665`، نه یک عدد صحیح.

#### عملگرهای انتساب (Assignment Operators)

شما قبلاً از رایج‌ترین عملگر انتساب، `=` استفاده کرده‌اید.
برای مختصرتر کردن کد خود، می‌توانید عملگر انتساب را با سایر عملگرها مانند عملگرهای حسابی ترکیب کنید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
int p = 6;
p += 3; // Equivalent to: p = p + 3;
p -= 3; // Equivalent to: p = p - 3;
p *= 3; // Equivalent to: p = p * 3;
p /= 3; // Equivalent to: p = p / 3;
```

#### عملگرهای ادغام نال (Null-coalescing Operators)

عملگرهای مرتبط با عملگرهای انتساب، عملگرهای ادغام نال هستند. گاهی اوقات، می‌خواهید یک متغیر را به یک نتیجه اختصاص دهید یا اگر متغیر `null` است، یک مقدار جایگزین اختصاص دهید. می‌توانید این کار را با استفاده از عملگرهای ادغام نال، `??` یا `??=` انجام دهید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
string? authorName = ReadLine(); // Prompt user to enter an author name.

// The maxLength variable will be the length of authorName if it is
// not null, or 30 if authorName is null.
int maxLength = authorName?.Length ?? 30;

// The authorName variable will be "unknown" if authorName was null.
authorName ??= "unknown";
```

#### کاوش عملگرهای منطقی (Logical Operators)

عملگرهای منطقی روی مقادیر بولی (Boolean) عمل می‌کنند، بنابراین یا `true` برمی‌گردانند یا `false`. بیایید عملگرهای منطقی دوتایی را که روی دو مقدار بولی عمل می‌کنند (که به‌طور سنتی در ریاضیات `p` و `q` نامیده می‌شوند) بررسی کنیم:

۱. در `Program.cs`، دستوراتی اضافه کنید تا دو متغیر بولی `p` و `q` را با مقادیر `true` و `false` تعریف کنید، و سپس جداول درستی (truth tables) را که نتایج اعمال عملگرهای منطقی AND ،OR و XOR (exclusive OR) را نشان می‌دهند، چاپ کنید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
bool p = true;
bool q = false;
WriteLine($"AND  | p     | q    ");
WriteLine($"p    | {p & p,-5} | {p & q,-5} ");
WriteLine($"q    | {q & p,-5} | {q & q,-5} ");
WriteLine();
WriteLine($"OR   | p     | q    ");
WriteLine($"p    | {p | p,-5} | {p | q,-5} ");
WriteLine($"q    | {q | p,-5} | {q | q,-5} ");
WriteLine();
WriteLine($"XOR  | p     | q    ");
WriteLine($"p    | {p ^ p,-5} | {p ^ q,-5} ");
WriteLine($"q    | {q ^ p,-5} | {q ^ q,-5} ");
```

> به یاد داشته باشید که `,-5` به معنای چپ‌چین کردن در ستونی با عرض پنج کاراکتر است.

۲. کد را اجرا کنید و به نتایج توجه کنید، همان‌طور که در خروجی زیر نشان داده شده است:

```text
AND  | p     | q
p    | True  | False
q    | False | False
OR   | p     | q
p    | True  | True
q    | True  | False
XOR  | p     | q
p    | False | True
q    | True  | False
```

برای عملگر منطقی **AND** (`&`)، هر دو عملوند باید `true` باشند تا نتیجه `true` شود. برای عملگر منطقی **OR** (`|`)، هر کدام از عملوندها می‌توانند `true` باشند تا نتیجه `true` شود. برای عملگر منطقی **XOR** (`^`)، هر کدام از عملوندها می‌توانند `true` باشند (اما نه هر دو!) تا نتیجه `true` شود.

#### کاوش عملگرهای منطقی شرطی (Conditional Logical Operators)

عملگرهای منطقی شرطی مانند عملگرهای منطقی هستند، اما شما از دو نماد به جای یکی استفاده می‌کنید، برای مثال `&&` به جای `&`، یا `||` به جای `|`.

در فصل ۴، *نوشتن، اشکال‌زدایی و تست توابع*، درباره توابع با جزئیات بیشتر یاد خواهید گرفت، اما من باید توابع را الان معرفی کنم تا عملگرهای منطقی شرطی را توضیح دهم، که به عنوان **عملگرهای بولی اتصال کوتاه (short-circuiting Boolean operators)** نیز شناخته می‌شوند.

یک تابع دستوراتی را اجرا می‌کند و سپس مقداری را برمی‌گرداند. آن مقدار می‌تواند یک مقدار بولی مانند `true` باشد که در یک عملیات بولی استفاده می‌شود. بیایید از عملگرهای منطقی شرطی استفاده کنیم:

۱. در انتهای `Program.cs`، دستوراتی بنویسید تا تابعی را تعریف کنید که پیامی را در کنسول می‌نویسد و `true` برمی‌گرداند، همان‌طور که در کد زیر نشان داده شده است:

```csharp
static bool DoStuff()
{
    WriteLine("I am doing some stuff.");
    return true;
}
```

> توابع محلی می‌توانند هر جایی در میان دستورات در `Program.cs` که از ویژگی برنامه سطح بالا استفاده می‌کند باشند، اما تمرین خوبی است که آن‌ها را در انتهای فایل قرار دهید.

۲. بعد از دستورات `WriteLine` قبلی، یک عملیات AND (`&`) روی متغیرهای `p` و `q`، و نتیجه فراخوانی تابع انجام دهید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
WriteLine();
// Note that DoStuff() returns true.
WriteLine($"p & DoStuff() = {p & DoStuff()}");
WriteLine($"q & DoStuff() = {q & DoStuff()}");
```

۳. کد را اجرا کنید، نتیجه را مشاهده کنید، و توجه کنید که تابع دو بار فراخوانی شده است، یک بار برای `p` و یک بار برای `q`، همان‌طور که در خروجی زیر نشان داده شده است:

```text
I am doing some stuff.
p & DoStuff() = True
I am doing some stuff.
q & DoStuff() = False
```

۴. سه دستور را کپی و پیست کنید و سپس عملگرهای `&` را به عملگرهای `&&` تغییر دهید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
WriteLine();
WriteLine($"p && DoStuff() = {p && DoStuff()}");
WriteLine($"q && DoStuff() = {q && DoStuff()}");
```

۵. کد را اجرا کنید، نتیجه را مشاهده کنید، و توجه کنید که تابع زمانی که با متغیر `p` ترکیب می‌شود اجرا می‌شود. اما زمانی که با متغیر `q` ترکیب می‌شود اجرا **نمی‌شود** زیرا متغیر `q` مقدار `false` دارد، بنابراین نتیجه در هر صورت `false` خواهد بود، پس نیازی به اجرای تابع نیست، همان‌طور که در خروجی زیر نشان داده شده است:

```text
I am doing some stuff.
p && DoStuff() = True
q && DoStuff() = False // DoStuff function was not executed!
```

> **تمرین خوب:**
> حالا می‌توانید ببینید چرا عملگرهای منطقی شرطی به عنوان اتصال کوتاه (short-circuiting) توصیف می‌شوند. آن‌ها می‌توانند برنامه‌های شما را کارآمدتر کنند، اما همچنین می‌توانند باگ‌های ظریفی را در مواردی که فرض می‌کنید تابع همیشه فراخوانی خواهد شد، ایجاد کنند. امن‌ترین کار این است که هنگام استفاده ترکیبی با توابعی که اثرات جانبی (side effects) دارند، از آن‌ها اجتناب کنید.

#### کاوش عملگرهای بیتی (Bitwise) و شیفت باینری (Binary Shift)

عملگرهای بیتی بیت‌های موجود در نمایش باینری یک عدد را مقایسه می‌کنند. هر بیت، یعنی مقدار ۰ (صفر) یا ۱ (یک)، به‌صورت جداگانه با بیت موجود در همان ستون مقایسه می‌شود.
عملگرهای شیفت باینری می‌توانند برخی محاسبات حسابی رایج را بسیار سریع‌تر از عملگرهای سنتی انجام دهند، برای مثال، هر ضرب در ضریبی از ۲.

بیایید عملگرهای بیتی و شیفت باینری را بررسی کنیم:

۱. در `Program.cs`، دستوراتی اضافه کنید تا دو متغیر عدد صحیح به نام‌های `x` و `y` با مقادیر ۱۰ و ۶ تعریف کنید، و سپس نتایج اعمال عملگرهای بیتی AND ،OR و XOR را چاپ کنید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
WriteLine();
int x = 10;
int y = 6;
WriteLine($"Expression | Decimal | Binary");
WriteLine($"-------------------------------");
WriteLine($"x | {x,7} | {x:B8}");
WriteLine($"y | {y,7} | {y:B8}");
WriteLine($"x & y | {x & y,7} | {x & y:B8}");
WriteLine($"x | y | {x | y,7} | {x | y:B8}");
WriteLine($"x ^ y | {x ^ y,7} | {x ^ y:B8}");
```

> به یاد داشته باشید که `,7` به معنای راست‌چین کردن در ستونی با عرض هفت و `:B8` به معنای فرمت‌دهی در باینری با هشت رقم است.

۲. کد را اجرا کنید و به نتایج توجه کنید، همان‌طور که در خروجی زیر نشان داده شده است:

```text
Expression | Decimal | Binary
-------------------------------
x          |      10 | 00001010
y          |       6 | 00000110
x & y      |       2 | 00000010
x | y      |      14 | 00001110
x ^ y      |      12 | 00001100
```

برای `x & y`، تنها ستون بیت ۲ تنظیم شده است. برای `x | y`، ستون‌های بیت ۸، ۴ و ۲ تنظیم شده‌اند. برای `x ^ y`، ستون‌های ۸ و ۴ تنظیم شده‌اند.

۳. در `Program.cs`، دستوراتی اضافه کنید تا نتایج اعمال عملگر شیفت چپ برای جابجایی بیت‌های متغیر `x` به اندازه سه ستون، ضرب `x` در ۸، و شیفت راست بیت‌های متغیر `y` به اندازه یک ستون را چاپ کنید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
// Left-shift x by three bit columns.
WriteLine($"x << 3 | {x << 3,7} | {x << 3:B8}");
// Multiply x by 8.
WriteLine($"x * 8 | {x * 8,7} | {x * 8:B8}");
// Right-shift y by one bit column.
WriteLine($"y >> 1 | {y >> 1,7} | {y >> 1:B8}");
```

۴. کد را اجرا کنید و به نتایج توجه کنید، همان‌طور که در خروجی زیر نشان داده شده است:

```text
x << 3     |      80 | 01010000
x * 8      |      80 | 01010000
y >> 1     |       3 | 00000011
```

نتیجه ۸۰ به این دلیل است که بیت‌ها در آن سه ستون به چپ شیفت داده شدند، بنابراین بیت‌های ۱ به ستون‌های ۶۴ و ۱۶ منتقل شدند، و ۶۴ + ۱۶ = ۸۰. این معادل ضرب در ۸ است، اما CPUها می‌توانند شیفت بیتی را سریع‌تر انجام دهند. نتیجه ۳ به این دلیل است که بیت‌های ۱ در `y` یک ستون به ستون‌های ۲ و ۱ شیفت داده شدند.

> **تمرین خوب:**
> به یاد داشته باشید که هنگام عملیات روی مقادیر صحیح، نمادهای `&` و `|` عملگرهای بیتی هستند، و هنگام عملیات روی مقادیر بولی مانند `true` و `false`، نمادهای `&` و `|` عملگرهای منطقی هستند.
