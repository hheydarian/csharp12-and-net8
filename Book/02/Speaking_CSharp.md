# فصل دوم: Speaking C #

این فصل تماماً در مورد مبانی زبان برنامه‌نویسی C# است. در طول این فصل، یاد خواهید گرفت که چگونه با استفاده از دستور زبان (grammar) C# دستورات (statements) را بنویسید، و همچنین با برخی از واژگان رایجی که هر روز استفاده خواهید کرد، آشنا می‌شوید. علاوه بر این، تا پایان فصل، در دانستن نحوه ذخیره و کار با اطلاعات در حافظه کامپیوتر خود به صورت موقت، احساس اطمینان خواهید کرد.

این فصل موضوعات زیر را پوشش می‌دهد:

* معرفی زبان C#
* کشف نسخه کامپایلر C# شما
* درک دستور زبان و واژگان C#
* کار با متغیرها
* کاوش بیشتر درباره برنامه‌های کنسول
* درک async و await

### معرفی زبان C #

این بخش از کتاب درباره زبان C# است—دستور زبان و واژگانی که هر روز برای نوشتن کد منبع (source code) برنامه‌های خود استفاده خواهید کرد.

زبان‌های برنامه‌نویسی شباهت‌های زیادی به زبان‌های انسانی دارند، با این تفاوت که در زبان‌های برنامه‌نویسی، شما می‌توانید کلمات خودتان را بسازید، درست مثل دکتر زوس (Dr. Seuss)!
در کتابی که دکتر زوس در سال ۱۹۵۰ نوشت، *اگر من باغ‌وحش را اداره می‌کردم* (If I Ran the Zoo)، او چنین بیان می‌کند:
> «و آنگاه، فقط برای اینکه به آن‌ها نشان دهم، به کا-ترو (Ka-Troo) سفر خواهم کرد و یک ایت-کاچ (It-Kutch)، یک پریپ (Preep) و یک پرو (Proo)، یک نرکل (Nerkle)، یک نرد (Nerd) و یک سیرساکر (Seersucker) را هم با خود خواهم آورد!»

#### نسخه‌ها و ویژگی‌های زبان C #

این بخش از کتاب زبان برنامه‌نویسی C# را پوشش می‌دهد و عمدتاً برای مبتدیان نوشته شده است، بنابراین موضوعات بنیادی را که همه توسعه‌دهندگان باید بدانند، از جمله تعریف متغیرها، ذخیره داده‌ها و چگونگی تعریف انواع داده سفارشی، پوشش می‌دهد.

این کتاب ویژگی‌های زبان C# را از نسخه ۱ تا آخرین نسخه، یعنی ۱۲، پوشش می‌دهد. اگر قبلاً با نسخه‌های قدیمی‌تر C# آشنایی دارید و مشتاقید تا درباره ویژگی‌های جدید در آخرین نسخه‌های C# بدانید، من با فهرست کردن نسخه‌های زبان و ویژگی‌های مهم جدید آن‌ها در زیر، به همراه شماره فصل و عنوان موضوعی که می‌توانید در آنجا درباره آن‌ها بیاموزید، پرش به بخش‌های مختلف را برای شما آسان‌تر کرده‌ام. شما می‌توانید این اطلاعات را در مخزن GitHub در لینک زیر مطالعه کنید:
[https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch02-features.md](https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch02-features.md)

#### درک استانداردهای C #

در طول سال‌ها، مایکروسافت چندین نسخه از C# را به نهادهای استانداردسازی ارسال کرده است، همان‌طور که در جدول ۲.۱ نشان داده شده است:

| C# version | ECMA standard | ISO/IEC standard |
| :--- | :--- | :--- |
| 1.0 | ECMA-334:2003 | ISO/IEC 23270:2003 |
| 2.0 | ECMA-334:2006 | ISO/IEC 23270:2006 |
| 5.0 | ECMA-334:2017 | ISO/IEC 23270:2018 |
| 6.0 | ECMA-334:2022 | ISO/IEC 23270:2022 |

*جدول ۲.۱: استانداردهای ECMA برای C#*

استاندارد ECMA برای C# 7.3 هنوز یک پیش‌نویس است. پس حتی فکرش را هم نکنید که نسخه‌های ۸ تا ۱۲ C# چه زمانی ممکن است استاندارد ECMA شوند! مایکروسافت در سال ۲۰۱۴ C# را متن‌باز (open source) کرد. شما می‌توانید آخرین سند استاندارد C# را در لینک زیر مطالعه کنید:
[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/specifications](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/specifications)

مفیدتر از استانداردهای ECMA از نظر عملی، مخازن عمومی GitHub برای باز نگه داشتن کار روی C# و فناوری‌های مرتبط تا حد امکان است، همان‌طور که در جدول ۲.۲ نشان داده شده است:

| Description | Link |
| :--- | :--- |
| C# language design | [https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang) |
| Compiler implementation | [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn) |
| Standard to describe the language | [https://github.com/dotnet/csharpstandard](https://github.com/dotnet/csharpstandard) |

*جدول ۲.۲: مخازن عمومی GitHub برای C#*

### کشف نسخه کامپایلر C# شما

کامپایلر زبان .NET برای C# و ویژوال بیسیک، که به نام **Roslyn** نیز شناخته می‌شود، همراه با یک کامپایلر جداگانه برای F#، به عنوان بخشی از .NET SDK توزیع می‌شود. برای استفاده از یک نسخه خاص از C#، باید حداقل آن نسخه از .NET SDK را نصب داشته باشید، همان‌طور که در جدول ۲.۳ نشان داده شده است:

| .NET SDK | Roslyn compiler | Default C# language |
| :--- | :--- | :--- |
| 1.0 | 2.0-2.2 | 7.0 |
| 1.1 | 2.3-2.4 | 7.1 |
| 2.1.2 | 2.6-2.7 | 7.2 |
| 2.1.200 | 2.8-2.10 | 7.3 |
| 3.0 | 3.0-3.4 | 8.0 |
| 5.0 | 3.8 | 9.0 |
| 6.0 | 4.0 | 10.0 |
| 7.0 | 4.4 | 11.0 |
| 8.0 | 4.8 | 12.0 |

*جدول ۲.۳: نسخه‌های .NET SDK و نسخه‌های کامپایلر C# آن‌ها*

هنگامی که کتابخانه‌های کلاس (class libraries) ایجاد می‌کنید، می‌توانید انتخاب کنید که علاوه بر نسخه‌های .NET مدرن، .NET Standard را نیز هدف قرار دهید (target). آن‌ها دارای نسخه‌های پیش‌فرض زبان C# هستند، همان‌طور که در جدول ۲.۴ نشان داده شده است:

| .NET Standard | C# |
| :--- | :--- |
| 2.0 | 7.3 |
| 2.1 | 8.0 |

*جدول ۲.۴: نسخه‌های .NET Standard و نسخه‌های پیش‌فرض کامپایلر C# آن‌ها*

> اگرچه برای دسترسی به نسخه خاصی از کامپایلر باید حداقل نسخه‌ای از .NET SDK را نصب کرده باشید، اما پروژه‌هایی که ایجاد می‌کنید می‌توانند نسخه‌های قدیمی‌تر .NET را هدف قرار دهند و همچنان از نسخه مدرن کامپایلر استفاده کنند. برای مثال، اگر .NET 7 SDK یا بالاتر را نصب کرده باشید، می‌توانید از ویژگی‌های زبان C# 11 در یک برنامه کنسول که .NET Core 3.0 را هدف قرار می‌دهد، استفاده کنید.

#### نحوه دریافت خروجی نسخه SDK

بیایید ببینیم چه نسخه‌هایی از .NET SDK و کامپایلر زبان C# را در دسترس دارید:

۱. در ویندوز، **Windows Terminal** یا **Command Prompt** را اجرا کنید. در macOS، **Terminal** را اجرا کنید.
۲. برای تعیین اینکه کدام نسخه از .NET SDK را در دسترس دارید، دستور زیر را وارد کنید:

```bash
dotnet --version
```

۳. توجه داشته باشید که نسخه در زمان انتشار این کتاب `8.0.100` است، که نشان می‌دهد این نسخه اولیه SDK بدون هیچ‌گونه رفع باگ یا ویژگی جدیدی تا آن لحظه است، همان‌طور که در خروجی زیر نشان داده شده است:

```text
8.0.100
```

#### فعال‌سازی کامپایلر یک نسخه خاص زبان

ابزارهای توسعه مانند Visual Studio و رابط خط فرمان dotnet فرض می‌کنند که شما می‌خواهید به طور پیش‌فرض از آخرین نسخه اصلی (major version) کامپایلر زبان C# استفاده کنید. قبل از انتشار C# 8، نسخه C# 7 آخرین نسخه اصلی بود و به طور پیش‌فرض استفاده می‌شد. برای استفاده از بهبودهای موجود در نسخه‌های میانی (point release) مانند ۷.۱، ۷.۲ یا ۷.۳، شما مجبور بودید یک... [ادامه متن در بخش بعد]

> **هشدار!**
> برخی از ویژگی‌های زبان C# به تغییرات در کتابخانه‌های زیرین .NET وابسته هستند. حتی اگر از آخرین SDK با آخرین کامپایلر استفاده کنید، ممکن است نتوانید از تمام ویژگی‌های جدید زبان در حالی که نسخه قدیمی‌تری از .NET را هدف قرار داده‌اید، استفاده کنید. برای مثال، C# 11 کلمه کلیدی `required` را معرفی کرد، اما نمی‌توان از آن در پروژه‌ای که .NET 6 را هدف قرار می‌دهد استفاده کرد، زیرا آن ویژگی زبانی به ویژگی‌های (Attributes) جدیدی نیاز دارد که فقط در .NET 7 موجود هستند. خوشبختانه، اگر سعی کنید از ویژگی C# که پشتیبانی نمی‌شود استفاده کنید، کامپایلر به شما هشدار می‌دهد. فقط برای آن احتمال آماده باشید.

---

#### نمایش نسخه کامپایلر

ما کار را با نوشتن کدی آغاز می‌کنیم که نسخه کامپایلر را نمایش می‌دهد:

۱. اگر فصل ۱، *سلام، C# ! خوش آمدی، .NET !* را تکمیل کرده‌اید، پس از قبل پوشه `cs12dotnet8` را دارید. اگر نه، باید آن را ایجاد کنید.

۲. از ویرایشگر کد مورد نظر خود برای ایجاد یک پروژه جدید استفاده کنید، همان‌طور که در لیست زیر تعریف شده است:

* **قالب پروژه:** Console App [C#] / console
* **فایل پروژه و پوشه:** Vocabulary
* **فایل Solution و پوشه:** Chapter02
* **Do not use top-level statements:** تیک نخورده باشد (غیرفعال)
* **Enable native AOT publish:** تیک نخورده باشد (غیرفعال)

> **تمرین خوب:**
> اگر فراموش کرده‌اید چگونه، یا فصل قبل را تکمیل نکرده‌اید، دستورالعمل‌های گام‌به‌گام برای ایجاد یک Solution با چندین پروژه در فصل ۱، *سلام، C# ! خوش آمدی، .NET !* ارائه شده است.

۳. در پروژه `Vocabulary`، در فایل `Program.cs`، بعد از توضیحات (comment)، دستوری اضافه کنید تا نسخه C# را به عنوان یک خطا نشان دهد، همان‌طور که در کد زیر آمده است:

```csharp
#error version
```

۴. برنامه کنسول را اجرا کنید:

* اگر از **Visual Studio 2022** استفاده می‌کنید، به مسیر **Debug | Start Without Debugging** بروید. هنگامی که از شما خواسته شد ادامه دهید و آخرین بیلد موفق را اجرا کنید، روی **No** کلیک کنید.
* اگر از **Visual Studio Code** استفاده می‌کنید، در یک ترمینال برای پوشه `Vocabulary`، دستور `dotnet run` را وارد کنید. توجه داشته باشید که ما انتظار خطای کامپایلر را داریم، پس وقتی آن را دیدید وحشت نکنید!

۵. توجه داشته باشید که نسخه کامپایلر و نسخه زبان به عنوان پیام خطای کامپایلر شماره `CS8304` ظاهر می‌شود، همان‌طور که در شکل ۲.۱ نشان داده شده است:

 <div align="center">

![Conventions-UsedThis-Book](../../assets/images/02/1.png)
</div>

پیام خطا در پنجره **PROBLEMS** در Visual Studio Code یا پنجره **Error List** در Visual Studio می‌گوید:
`Compiler version: '4.8.0...' with language version default (12.0).`

۶. دستوری که باعث خطا شده است را کامنت کنید (غیرفعال کنید)، همان‌طور که در کد زیر نشان داده شده است:

```csharp
// #error version
```

۷. توجه داشته باشید که پیام‌های خطای کامپایلر ناپدید می‌شوند.

### درک دستور زبان و واژگان C #

بیایید با نگاهی به مبانی دستور زبان (grammar) و واژگان (vocabulary) در C# شروع کنیم. در طول این فصل، شما چندین برنامه کنسول ایجاد خواهید کرد که هر کدام ویژگی‌های مرتبط زبان C# را نشان می‌دهند.

#### درک دستور زبان C #

دستور زبان C# شامل دستورات (statements) و بلوک‌ها (blocks) است. برای مستندسازی کد خود، می‌توانید از توضیحات (comments) استفاده کنید.

> **تمرین خوب:**
> توضیحات (Comments) نباید تنها راهی باشند که کد خود را مستند می‌کنید. انتخاب نام‌های معقول برای متغیرها و توابع، نوشتن تست‌های واحد (unit tests)، و ایجاد مستندات واقعی، راه‌های دیگری برای مستندسازی کد شما هستند.

#### دستورات (Statements)

در زبان انگلیسی، ما پایان یک جمله را با نقطه مشخص می‌کنیم. یک جمله می‌تواند از چندین کلمه و عبارت تشکیل شده باشد، که ترتیب کلمات بخشی از دستور زبان است. برای مثال، در انگلیسی می‌گوییم "the black cat".
صفت، یعنی `black`، قبل از اسم، یعنی `cat` می‌آید. در حالی که دستور زبان فرانسوی ترتیب متفاوتی دارد؛ صفت بعد از اسم می‌آید: "le chat noir".
آنچه مهم است از این موضوع برداشت کنید این است که **ترتیب اهمیت دارد**.

C# پایان یک دستور را با نقطه ویرگول (semicolon) `;` مشخص می‌کند. یک دستور می‌تواند از چندین نوع، متغیر و عبارت (expression) تشکیل شده باشد که از توکن‌ها (tokens) ساخته شده‌اند. هر توکن توسط فضای خالی (white space) یا یک توکن دیگر که به وضوح متفاوت است، مانند یک عملگر (operator)، مثلاً `=` یا `+`، جدا می‌شود.

برای مثال، در دستور زیر، `decimal` یک نوع (type)، `totalPrice` یک متغیر، و `subtotal + salesTax` یک عبارت است:

```csharp
decimal totalPrice = subtotal + salesTax;
```

این عبارت از یک عملوند (operand) به نام `subtotal`، یک عملگر `+`، و عملوند دیگری به نام `salesTax` ساخته شده است. ترتیب عملوندها و عملگرها اهمیت دارد زیرا ترتیب بر معنی و نتیجه تأثیر می‌گذارد.

#### توضیحات (Comments)

توضیحات روش اصلی مستندسازی کد شما برای افزایش درک نحوه کارکرد آن هستند، تا سایر توسعه‌دهندگان بتوانند آن را بخوانند، یا حتی خودتان وقتی ماه‌ها بعد به آن برمی‌گردید، بتوانید آن را بخوانید.

> در فصل ۴، *نوشتن، اشکال‌زدایی و تست توابع*، درباره توضیحات XML که با سه اسلش `///` شروع می‌شوند و با ابزاری برای تولید صفحات وب جهت مستندسازی کد شما کار می‌کنند، یاد خواهید گرفت.

شما می‌توانید با استفاده از دو اسلش `//` توضیحاتی برای تشریح کد خود اضافه کنید. کامپایلر همه چیز را بعد از `//` تا پایان خط نادیده می‌گیرد، همان‌طور که در کد زیر نشان داده شده است:

```csharp
// Sales tax must be added to the subtotal.
var totalPrice = subtotal + salesTax;
```

برای نوشتن توضیحات چندخطی، از `/*` در ابتدا و `*/` در انتهای توضیح استفاده کنید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
/* This is a multi-line comment. */
```

اگرچه `/* */` بیشتر برای توضیحات چندخطی استفاده می‌شود، اما برای درج توضیح در وسط یک دستور نیز مفید است، همان‌طور که در کد زیر نشان داده شده است:

```csharp
decimal totalPrice = subtotal /* for this item */ + salesTax;
```

> **تمرین خوب:**
> کدِ خوب طراحی شده، شامل امضاهای تابع با پارامترهای خوش‌نام و کپسوله‌سازی کلاس، می‌تواند تا حدودی خود-مستند (self-documenting) باشد. وقتی می‌بینید که توضیحات و تشریحات بیش از حدی در کد خود قرار می‌دهید، از خود بپرسید: آیا می‌توانم این کد را بازنویسی (refactor) کنم تا بدون توضیحات طولانی قابل درک‌تر شود؟

ویرایشگر کد شما دستوراتی برای آسان‌تر کردن افزودن و حذف کاراکترهای توضیحات دارد، همان‌طور که در لیست زیر نشان داده شده است:

* **Visual Studio 2022:** به مسیر **Edit | Advanced | Comment Selection** یا **Uncomment Selection** بروید.
* **Visual Studio Code:** به مسیر **Edit | Toggle Line Comment** یا **Toggle Block Comment** بروید.
* **JetBrains Rider:** به مسیر **Code | Comment with Line Comment** یا **Comment with Block Comment** بروید.

> **تمرین خوب:**
> شما با افزودن متن توصیفی در بالا یا بعد از دستورات کد، کد را **توضیح می‌دهید (Comment)**.
> شما با افزودن کاراکترهای توضیحات قبل یا اطراف دستورات، کد را **کامنت می‌کنید (Comment out)** تا آن‌ها را غیرفعال کنید.
> **Uncommenting** به معنای حذف کاراکترهای توضیحات است.

---

#### بلوک‌ها (Blocks)

در زبان انگلیسی، ما شروع یک پاراگراف جدید را با شروع یک خط جدید نشان می‌دهیم. C# یک بلوک کد را با استفاده از کروشه، `{ }` نشان می‌دهد. بلوک‌ها با یک اعلان (declaration) شروع می‌شوند تا مشخص کنند چه چیزی در حال تعریف است. برای مثال، یک بلوک می‌تواند شروع و پایان بسیاری از ساختارهای زبانی را تعریف کند، از جمله فضاهای نام (namespaces)، کلاس‌ها، متدها، یا دستوراتی مانند `foreach`.

شما در ادامه این فصل و فصل‌های بعدی درباره فضاهای نام، کلاس‌ها و متدها بیشتر یاد خواهید گرفت، اما برای معرفی مختصر برخی از آن مفاهیم در حال حاضر:

* یک **namespace** (فضای نام) شامل انواعی مانند کلاس‌ها است تا آن‌ها را با هم گروه‌بندی کند.
* یک **class** (کلاس) شامل اعضای یک شیء (object)، از جمله متدها است.
* یک **method** (متد) شامل دستوراتی است که عملی را که یک شیء می‌تواند انجام دهد، پیاده‌سازی می‌کند.

ویرایشگرهای کد مانند Visual Studio 2022 و Visual Studio Code ویژگی کارآمدی برای جمع کردن (collapse) و باز کردن (expand) بلوک‌ها با تغییر وضعیت `[-]` یا `[+]` یا یک نماد فلش رو به پایین یا راست در زمانی که مکان‌نمای ماوس خود را روی حاشیه سمت چپ کد می‌برید، ارائه می‌دهند، همان‌طور که در شکل ۲.۲ نشان داده شده است:

 <div align="center">

![Conventions-UsedThis-Book](../../assets/images/02/2.png)
</div>

#### ناحیه‌ها (Regions)

شما می‌توانید نواحی برچسب‌دار (labeled regions) خود را در اطراف هر دستوراتی که می‌خواهید تعریف کنید و سپس اکثر ویرایشگرهای کد به شما اجازه می‌دهند آن‌ها را به همان روش بلوک‌ها جمع و باز کنید، همان‌طور که در کد زیر نشان داده شده است:

```csharp
#region Three variables that store the number 2 million.
int decimalNotation = 2_000_000;
int binaryNotation = 0b_0001_1110_1000_0100_1000_0000;
int hexadecimalNotation = 0x_001E_8480;
#endregion
```

به این ترتیب، نواحی می‌توانند به عنوان بلوک‌های کامنت شده (commented blocks) در نظر گرفته شوند که می‌توانند جمع شوند تا خلاصه‌ای از آنچه بلوک انجام می‌دهد را نشان دهند. من از بلوک‌های `#region` در سراسر کدهای Solution در مخزن گیت‌هاب استفاده خواهم کرد، به خصوص برای فصل‌های اولیه قبل از اینکه شروع به تعریف توابعی کنیم که به عنوان نواحی طبیعی قابل جمع شدن عمل می‌کنند، اما آن‌ها را در کتاب چاپی نشان نخواهم داد تا در فضا صرفه‌جویی شود. از قضاوت خود برای تصمیم‌گیری در مورد استفاده از نواحی در کد خود استفاده کنید.

#### مثال‌هایی از دستورات و بلوک‌ها

در یک برنامه کنسول ساده که از ویژگی برنامه سطح بالا (top-level program) استفاده نمی‌کند، من تعدادی توضیحات به دستورات و بلوک‌ها اضافه کرده‌ام، همان‌طور که در کد زیر نشان داده شده است:

```csharp
using System; // A semicolon indicates the end of a statement.
namespace Basics
{ // An open brace indicates the start of a block.
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!"); // A statement.
        }
    }
} // A close brace indicates the end of a block.
```

توجه داشته باشید که C# از سبک کروشه‌ای استفاده می‌کند که در آن هر دو کروشه باز و بسته در خط خودشان هستند و در یک سطح دندانه‌گذاری (indentation) قرار دارند، همان‌طور که در کد زیر نشان داده شده است:

```csharp
if (x < 3)
{
    // Do something if x is less than 3.
}
```

سایر زبان‌ها مانند جاوا اسکریپت از کروشه استفاده می‌کنند اما آن‌ها را متفاوت فرمت‌دهی می‌کنند. آن‌ها کروشه باز را در انتهای دستور اعلان قرار می‌دهند، همان‌طور که در کد زیر نشان داده شده است:

```csharp
if (x < 3) {
    // Do something if x is less than 3.
}
```

شما می‌توانید از هر سبکی که ترجیح می‌دهید استفاده کنید زیرا کامپایلر اهمیتی نمی‌دهد. گاهی اوقات، برای صرفه‌جویی در فضای عمودی در یک کتاب چاپی، من از سبک کروشه جاوا اسکریپت استفاده می‌کنم، اما عمدتاً به سبک کروشه C# پایبند هستم. من به جای چهار فاصله رایج‌تر، از دو فاصله برای دندانه‌گذاری استفاده می‌کنم زیرا کد من در یک کتاب چاپ خواهد شد و بنابراین عرض باریکی در دسترس دارد.

> **اطلاعات بیشتر:** قراردادهای رسمی سبک کدنویسی را می‌توانید در لینک زیر بیابید:
> [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions)

صرف نظر از هر دستورالعمل رسمی، توصیه می‌کنم که از هر استانداردی که توسط تیم توسعه شما اتخاذ شده است پیروی کنید، مگر اینکه یک توسعه‌دهنده تنها باشید، که در این صورت تا زمانی که کد شما کامپایل می‌شود، می‌توانید از هر قراردادی که دوست دارید استفاده کنید. اما با ثابت‌قدم بودن در یک روش، با خودِ آینده‌تان مهربان باشید!

> **تمرین خوب:**
> سبک کروشه‌ای که در مستندات رسمی مایکروسافت استفاده می‌شود، رایج‌ترین سبک برای C# است. برای مثال، دستور `for` را در لینک زیر ببینید:
> [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements)

#### فرمت‌دهی کد با استفاده از فضای خالی (White Space)

فضای خالی شامل کاراکترهای فاصله (space)، تب (tab) و خط جدید (newline) است. شما می‌توانید از فضای خالی برای فرمت‌دهی کد خود به هر شکلی که دوست دارید استفاده کنید زیرا فضای خالی اضافی هیچ تأثیری بر کامپایلر ندارد. چهار دستور زیر همگی معادل هستند:

```csharp
int sum = 1 + 2; // Most developers would prefer this format.
int sum=1+ 2; // One statement over three lines.
int sum= 1 +2;int sum=1+2; // Two statements on one line.
```

تنها کاراکتر فضای خالیِ مورد نیاز در دستورات فوق، فاصله‌ای بین `int` و `sum` است تا به کامپایلر بگوید آن‌ها توکن‌های جداگانه‌ای هستند. هر کاراکتر فضای خالی واحد، مثلاً یک فاصله، تب یا خط جدید قابل قبول خواهد بود.

> **اطلاعات بیشتر:** شما می‌توانید تعریف رسمی فضای خالی C# را در لینک زیر بخوانید:
> [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#634-white-space](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#634-white-space)

### درک واژگان C #

واژگان C# از کلمات کلیدی (keywords)، کاراکترهای نمادین (symbol characters) و انواع (types) تشکیل شده است.

برخی از کلمات کلیدی رزرو شده و از پیش تعریف شده که در این کتاب خواهید دید و مکرراً استفاده خواهید کرد شامل `using`، `namespace`، `class`، `static`، `int`، `string`، `double`، `bool`، `if`، `switch`، `break`، `while`، `do`، `for`، `foreach`، `this` و `true` هستند.

برخی از کاراکترهای نمادین که خواهید دید شامل `"`، `'`، `+`، `-`، `*`، `/`، `%`، `@` و `$` هستند.

کلمات کلیدیِ زمینه‌ای (contextual keywords) دیگری وجود دارند که فقط در یک زمینه خاص معنای ویژه‌ای دارند، مانند `and`، `or`، `not`، `record` و `init`. با این حال، این بدان معناست که تنها حدود ۱۰۰ کلمه کلیدی واقعی C# در زبان وجود دارد.

> **تمرین خوب:**
> کلمات کلیدی C# از حروف تمام کوچک استفاده می‌کنند. اگرچه می‌توانید از حروف تمام کوچک برای نام‌های نوعِ (type names) خودتان استفاده کنید، اما نباید این کار را انجام دهید. با C# 11 و بالاتر، اگر این کار را انجام دهید، کامپایلر هشداری می‌دهد، همان‌طور که در خروجی زیر نشان داده شده است:
> `Warning CS8981 The type name 'person' only contains lower-cased ascii characters. Such names may become reserved for the language.`

#### مقایسه زبان‌های برنامه‌نویسی با زبان‌های انسانی

زبان انگلیسی بیش از ۲۵۰,۰۰۰ کلمه متمایز دارد، پس C# چطور با داشتن تنها حدود ۱۰۰ کلمه کلیدی کارش راه می‌افتد؟ علاوه بر این، چرا یادگیری C# با وجود داشتن تنها ۰.۰۴۱۶٪ از تعداد کلمات زبان انگلیسی اینقدر دشوار است؟

یکی از تفاوت‌های کلیدی بین یک زبان انسانی و یک زبان برنامه‌نویسی این است که توسعه‌دهندگان باید بتوانند "کلمات" جدید با معانی جدید تعریف کنند. جدا از (حدود) ۱۰۰ کلمه کلیدی در زبان C#، این کتاب به شما درباره برخی از صدها هزار "کلمه" که سایر توسعه‌دهندگان تعریف کرده‌اند، آموزش خواهد داد، اما شما همچنین یاد خواهید گرفت که چگونه "کلمات" خودتان را تعریف کنید.

برنامه‌نویسان در سراسر جهان باید انگلیسی یاد بگیرند زیرا اکثر زبان‌های برنامه‌نویسی از کلمات انگلیسی مانند "if" و "break" استفاده می‌کنند. زبان‌های برنامه‌نویسی وجود دارند که از سایر زبان‌های انسانی مانند عربی استفاده می‌کنند، اما آن‌ها نادر هستند. اگر به یادگیری بیشتر علاقه‌مندید، این ویدیوی یوتیوب نمایشی از یک زبان برنامه‌نویسی عربی را نشان می‌دهد:
[https://youtu.be/dkO8cdwf6v8](https://youtu.be/dkO8cdwf6v8)

#### تغییر طرح رنگ برای سینتکس C #

به‌صورت پیش‌فرض، Visual Studio 2022 و Visual Studio Code کلمات کلیدی C# را به رنگ آبی نشان می‌دهند تا تشخیص آن‌ها از سایر کدها که به‌صورت پیش‌فرض سیاه هستند، آسان‌تر شود. هر دو ابزار به شما امکان می‌دهند طرح رنگ را سفارشی کنید.

در **Visual Studio 2022**:
۱. به مسیر **Tools | Options** بروید.
۲. در کادر محاوره‌ای **Options**، در بخش **Environment**، گزینه **Fonts and Colors** را انتخاب کنید و سپس آیتم‌های نمایشی که می‌خواهید سفارشی کنید را انتخاب نمایید. همچنین می‌توانید به جای مرور کردن، بخش مورد نظر را جستجو کنید.

در **Visual Studio Code**:
۱. به مسیر **File | Preferences | Theme | Color Theme** بروید. در macOS در منوی Code است.
۲. یک تم رنگی انتخاب کنید. جهت اطلاع، من از تم رنگی **Light+ (default light)** استفاده می‌کنم تا اسکرین‌شات‌ها در کتاب چاپی بهتر دیده شوند.

در **JetBrains Rider**:
۱. به مسیر **File | Settings | Editor | Color Scheme** بروید.

#### کمک برای نوشتن کد صحیح

ویرایشگرهای متنی ساده مانند Notepad کمکی به نوشتن انگلیسی صحیح نمی‌کنند. به همین ترتیب، Notepad کمکی به نوشتن C# صحیح هم نخواهد کرد. Microsoft Word می‌تواند با برجسته کردن غلط‌های املایی با خطوط موج‌دار قرمز به شما در نوشتن انگلیسی کمک کند (مثلاً Word می‌گوید که "icecream" باید ice-cream یا ice cream باشد) و خطاهای گرامری را با خطوط موج‌دار آبی نشان دهد (مانند اینکه یک جمله باید با حرف بزرگ شروع شود).

به‌طور مشابه، افزونه C# در Visual Studio 2022 و Visual Studio Code با برجسته کردن غلط‌های املایی، مانند اینکه نام متد باید `WriteLine` با L بزرگ باشد، و خطاهای گرامری، مانند اینکه دستورات باید با نقطه ویرگول پایان یابند، به شما در نوشتن کد C# کمک می‌کند.

افزونه C# دائماً آنچه را که تایپ می‌کنید تماشا می‌کند و با برجسته کردن مشکلات با خطوط موج‌دار رنگی، مانند Microsoft Word، به شما بازخورد می‌دهد. بیایید آن را در عمل ببینیم:

۱. در `Program.cs`، حرف L در متد `WriteLine` را به حروف کوچک تغییر دهید.
۲. نقطه ویرگول انتهای دستور را حذف کنید.
۳. در Visual Studio Code به مسیر **View | Problems** بروید؛ در Visual Studio 2022 به مسیر **View | Error List** بروید؛ یا در JetBrains Rider به مسیر **View | Tool Windows | Problems** بروید و توجه کنید که یک خط موج‌دار قرمز زیر اشتباهات کد ظاهر می‌شود و جزئیات نشان داده می‌شود، همان‌طور که در شکل ۲.۳ می‌بینید:

 <div align="center">

![Conventions-UsedThis-Book](../../assets/images/02/3.png)
</div>

۴. دو خطای کدنویسی را اصلاح کنید.

#### وارد کردن (Importing) فضاهای نام

`System` یک فضای نام است، که شبیه آدرس برای یک نوع (type) است. برای اشاره دقیق به مکان یک نفر، ممکن است از `Oxford.HighStreet.BobSmith` استفاده کنید، که به ما می‌گوید به دنبال شخصی به نام Bob Smith در خیابان High Street در شهر Oxford بگردیم.

`System.Console.WriteLine` به کامپایلر می‌گوید که به دنبال متدی به نام `WriteLine` در نوعی به نام `Console` در فضای نامی به نام `System` بگردد.

برای ساده کردن کد ما، قالب پروژه Console App برای هر نسخه از .NET قبل از ۶.۰، دستوری را در بالای فایل کد اضافه می‌کرد تا به کامپایلر بگوید همیشه در فضای نام `System` به دنبال انواعی بگردد که با فضای نامشان پیشوند نشده‌اند، همان‌طور که در کد زیر نشان داده شده است:

```csharp
using System; // Import the System namespace.
```

ما به این کار **وارد کردن (importing) فضای نام** می‌گوییم. اثر وارد کردن یک فضای نام این است که تمام انواع موجود در آن فضای نام برای برنامه شما در دسترس خواهند بود، بدون اینکه نیاز باشد پیشوند فضای نام را وارد کنید. تمام انواع موجود در آن فضای نام در حالی که کد می‌نویسید در IntelliSense دیده خواهند شد.

#### وارد کردن ضمنی و سراسری فضاهای نام

به‌طور سنتی، هر فایل `.cs` که نیاز به وارد کردن فضاهای نام داشت، باید با دستورات `using` برای وارد کردن آن فضاهای نام شروع می‌شد. فضاهای نامی مانند `System` و `System.Linq` تقریباً در تمام فایل‌های `.cs` مورد نیاز هستند، بنابراین چند خط اول هر فایل `.cs` اغلب حداقل چند دستور `using` داشت، همان‌طور که در کد زیر نشان داده شده است:

```csharp
using System;
using System.Linq;
using System.Collections.Generic;
```

هنگام ایجاد وب‌سایت‌ها و سرویس‌ها با استفاده از ASP.NET Core، اغلب ده‌ها فضای نام وجود دارد که هر فایل باید وارد کند.

C# 10 ترکیب کلمه کلیدی جدیدی را معرفی کرد و .NET SDK 6 یک تنظیم پروژه جدید را معرفی کرد که با هم برای ساده کردن وارد کردن فضاهای نام رایج کار می‌کنند.

ترکیب کلمه کلیدی `global using` به این معنی است که شما فقط نیاز دارید یک فضای نام را در **یک** فایل `.cs` وارد کنید و آن در تمام فایل‌های `.cs` در دسترس خواهد بود، به جای اینکه مجبور باشید فضای نام را در بالای هر فایلی که به آن نیاز دارد وارد کنید.

شما می‌توانید دستورات `global using` را در فایل `Program.cs` قرار دهید، اما من توصیه می‌کنم یک فایل جداگانه برای آن دستورات با نامی مانند `GlobalUsings.cs` ایجاد کنید که محتویات آن تمام دستورات `global using` شما باشد، همان‌طور که در کد زیر نشان داده شده است:

```csharp
global using System;
global using System.Linq;
global using System.Collections.Generic;
```

> **تمرین خوب:**
> همان‌طور که توسعه‌دهندگان به این ویژگی جدید C# عادت می‌کنند، انتظار دارم یک قرارداد نام‌گذاری برای این فایل به استاندارد دفاکتو تبدیل شود. همان‌طور که خواهید دید، ویژگی مرتبطِ .NET SDK از یک قرارداد نام‌گذاری مشابه استفاده می‌کند.

هر پروژه‌ای که .NET 6 یا بالاتر را هدف قرار می‌دهد و بنابراین از کامپایلر C# 10 یا بالاتر استفاده می‌کند، یک فایل `<ProjectName>.GlobalUsings.g.cs` در پوشه `obj\Debug\net8.0` تولید می‌کند تا به‌طور ضمنی برخی از فضاهای نام رایج مانند `System` را به‌صورت سراسری وارد کند. لیست خاص فضاهای نامی که به‌صورت ضمنی وارد شده‌اند بستگی به SDK هدف شما دارد، همان‌طور که در جدول ۲.۶ نشان داده شده است:

| SDK | Implicitly imported namespaces |
| :--- | :--- |
| Microsoft.NET.Sdk | System<br>System.Collections.Generic<br>System.IO<br>System.Linq<br>System.Net.Http<br>System.Threading<br>System.Threading.Tasks |
| Microsoft.NET.Sdk.Web | Same as Microsoft.NET.Sdk and:<br>System.Net.Http.Json<br>Microsoft.AspNetCore.Builder<br>Microsoft.AspNetCore.Hosting<br>Microsoft.AspNetCore.Http<br>Microsoft.AspNetCore.Routing<br>Microsoft.Extensions.Configuration<br>Microsoft.Extensions.DependencyInjection<br>Microsoft.Extensions.Hosting<br>Microsoft.Extensions.Logging |
| Microsoft.NET.Sdk.Worker | Same as Microsoft.NET.Sdk and:<br>Microsoft.Extensions.Configuration<br>Microsoft.Extensions.DependencyInjection<br>Microsoft.Extensions.Hosting<br>Microsoft.Extensions.Logging |

*جدول ۲.۶: .NET SDKها و فضاهای نام ضمنی وارد شده آن‌ها*

بیایید فایل واردات ضمنیِ تولید شدهِ خودکارِ فعلی را ببینیم:

۱. در **Solution Explorer**، دکمه **Show All Files** را روشن کنید و توجه داشته باشید که پوشه‌های `bin` و `obj` تولید شده توسط کامپایلر اکنون قابل مشاهده هستند.

۲. در پروژه `Vocabulary`، پوشه `obj` را باز کنید، پوشه `Debug` را باز کنید، پوشه `net8.0` را باز کنید، و سپس فایلی به نام `Vocabulary.GlobalUsings.g.cs` را باز کنید.

> قرارداد نام‌گذاری برای این فایل `<ProjectName>.GlobalUsings.g.cs` است. به `g` برای `generated` (تولید شده) توجه کنید تا آن را از فایل‌های کدی که توسط توسعه‌دهنده نوشته شده‌اند متمایز کند.

۳. به یاد داشته باشید که این فایل به‌طور خودکار توسط کامپایلر برای پروژه‌هایی که .NET 6 و بالاتر را هدف قرار می‌دهند ایجاد می‌شود، و برخی از فضاهای نام رایج از جمله `System.Threading` را وارد می‌کند، همان‌طور که در کد زیر نشان داده شده است:

```csharp
// <autogenerated />
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
```

۴. فایل `Vocabulary.GlobalUsings.g.cs` را ببندید.

۵. در **Solution Explorer**، فایل پروژه `Vocabulary.csproj` را باز کنید، و سپس ورودی‌های اضافی را به فایل پروژه اضافه کنید تا کنترل کنید کدام فضاهای نام به‌صورت ضمنی وارد شوند، همان‌طور که در نشانه‌گذاری (markup) زیر برجسته شده است:

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <Using Remove="System.Threading" />
    <Using Include="System.Numerics" />
    <Using Include="System.Console" Static="true" />
    <Using Include="System.Environment" Alias="Env" />
  </ItemGroup>

</Project>
```

> توجه داشته باشید که `<ItemGroup>` با `<ImportGroup>` متفاوت است. مطمئن شوید که از مورد صحیح استفاده می‌کنید! همچنین، توجه داشته باشید که ترتیب عناصر در یک گروه پروژه یا گروه آیتم اهمیتی ندارد. برای مثال، `<Nullable>` می‌تواند قبل یا بعد از `<ImplicitUsings>` باشد.

۶. تغییرات فایل پروژه را ذخیره کنید.

۷. پوشه `obj` را باز کنید، پوشه `Debug` را باز کنید، پوشه `net8.0` را باز کنید و فایلی به نام `Vocabulary.GlobalUsings.g.cs` را باز کنید.

۸. توجه داشته باشید که این فایل اکنون `System.Numerics` را به جای `System.Threading` وارد می‌کند، کلاس `Environment` وارد شده و با نام مستعار `Env` نام‌گذاری شده است، و ما کلاس `Console` را به‌صورت استاتیک وارد کرده‌ایم، همان‌طور که در کد زیر برجسته شده است:

```csharp
// <autogenerated />
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Numerics;
global using global::System.Threading.Tasks;
global using Env = global::System.Environment;
global using static global::System.Console;
```

۹. در `Program.cs`، دستوری اضافه کنید تا پیامی از کامپیوتر را چاپ کند و توجه داشته باشید که چون ما کلاس `Console` را به‌صورت استاتیک وارد کرده‌ایم، می‌توانیم متدهای آن مانند `WriteLine` را بدون پیشوند `Console` فراخوانی کنیم، و می‌توانیم با استفاده از نام مستعار `Env` به کلاس `Environment` ارجاع دهیم، همان‌طور که در کد زیر نشان داده شده است:

```csharp
WriteLine($"Computer named {Env.MachineName} says \"No.\"");
```

۱۰. پروژه را اجرا کنید و به پیام توجه نمایید، همان‌طور که در خروجی زیر نشان داده شده است:

```text
Computer named DAVROS says "No."
```

> نام کامپیوتر شما متفاوت خواهد بود مگر اینکه کامپیوترهای خود را مانند من از روی شخصیت‌های *Doctor Who* نام‌گذاری کنید.

شما می‌توانید ویژگی فضاهای نام وارد شده به‌صورت ضمنی را برای تمام SDKها با حذف کامل عنصر `<ImplicitUsings>` از فایل پروژه، یا تغییر مقدار آن به `disable` غیرفعال کنید، همان‌طور که در نشانه‌گذاری زیر نشان داده شده است:

```xml
<ImplicitUsings>disable</ImplicitUsings>
```

> **تمرین خوب:**
> اگر بخواهید به صورت دستی یک فایل واحد با تمام دستورات `global using` ایجاد کنید، به جای اینکه احتمالاً یکی به‌صورت خودکار تولید شود و دیگران به‌صورت دستی ایجاد شوند، ممکن است این کار را انجام دهید. اما توصیه من این است که این ویژگی را فعال نگه دارید و فایل پروژه را تغییر دهید تا آنچه را که در فایل کلاسِ تولید شدهِ خودکار در سلسله‌مراتب پوشه `obj` گنجانده می‌شود، تغییر دهید.
